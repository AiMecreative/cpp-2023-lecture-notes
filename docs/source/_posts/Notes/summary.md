---
title: Notes | 睡前故事：程序设计（一）知识概要
date: 2024-01-08 13:03:08
category: Notes
mathjax: true
sticky: true
---

这篇文章主要针对《算法与程序设计I》，对其中的知识点做一个比较概括的总结，具体细节需要大家参照教材、作业和PPT仔细复习。

<!--more-->

## 摘要

本学期主要针对基本数据类型、控制语句、函数和指针进行学习，这些不仅是`C++`的基础，更是今后学习其它编程语言的关键。在下学期，我们将会学习C++最为强大的内容之一——面向对象编程（OOP），除了学会一些新颖的语法外，熟练运用本学期的知识能帮助大家写出 **更好** 的面向对象程序。

经过一个学期的编程作业，大家对下列知识点应该有所掌握：

- **基本数据类型**：在C++中 **常用** 的、 **基本** 的数据类型有 `bool, char, int, float, double, void`，这些都是C++内置的 **保留字（或称为关键字）**，我们在写程序时不能用保留字命名自己的变量 ；而在后半学期，我们也接触到了 **指针**，它的定义其实是在前面基本类型中增加了修饰符 `*`；如果进一步了解C++变量类型，还会发现这些数据类型的保留字其实是可以被修饰的，例如比较基础的 `const int`，`static long long int`，`unsigned double`，这些一般用于比较特殊的场合，不需要掌握。
- **控制语句**：控制流语句是程序的灵魂，你的程序几乎无时无刻都在做判断。而C++的控制语句是基于`if-else, switch-case, for, while (do-while)`进行展开的。它们的语法和用法是 **必须掌握** ，此外，如果你想写出不那么令人费解的程序，你还需要了解它们是如何用 `{、}` “分隔”变量的作用域的：例如`while`的内外都 **定义** 了变量`value`，那么在`while`语句里面改变你所看见的`value`，当`while`语句结束时，你所看到的`value`真的被改变了吗？当然，在批改大家程序的时候，仍然存在 **不规范** 使用语法的情况（注意，不是错误，而是不规范！），在编写程序的时候 **按照规范** 是一个比较好的职业操守，例如我们永远不喜欢这样的句子：`for(;i<10,j<100,k<1000;){//for 语句里面改变ijk}`，我们也不喜欢这样的句子：`for(int i = 0, int j = 1, int k = 2;;)`；这就好比在客厅做饭，在厨房待客——程序没有毛病，但是别人觉得你有毛病。
- **函数**：进入到函数这一章，大家的程序开始变得五花八门、光怪陆离，~~在批改作业的时候我不断感慨：原来C++还能这样写！~~ 话说回来，在此之前的程序，我们都是写在一个叫做 `main` 函数的里面，就仿佛是八股文一般，`int main(){return 0;}` 这些东西你别删，你的代码写在两个大括号中间（准确来说是`return 0;`前面）。那么学完了函数，我们发现这是一个叫做 `main` 的函数的定义，它的返回值类型是 `int`，因此必须（事实上由于`main`函数的特殊性，这里有些编译器会自动添加返回值，即使你没有写`return 0;`）有返回值，并且是`int`类型的返回值，一般是返回`0`，代表程序正常结束（可以这样理解），而函数参数列表为空，代表不接收任何参数（在某些场合，比如需要在命令行传入参数时，`main`函数的参数列表也可以不为空），在两个大括号之间的、也就是我们书写自己代码的地方，就是`main`函数的函数体。这就是一个标准的函数的 **定义**：函数名、函数参数列表、函数返回值、函数体。
  - **函数的定义**
  - **函数的声明**：将函数体替换为分号`;`，其中函数名、函数参数列表也称为函数签名
- **数组和指针**：如果有同学来问我关于指针、引用的一些细节，我经常的回复是“我也不知道”，“我去查查”等，因为在现代C++中，如果只是完成一些比较简单的上层任务，很少会用到指针（但引用会经常用到，包括下学期面向对象编程也会经常用到引用）。这一章主要的特色就是 **绕**。
  - 数组是 **相同数据类型的数据的、有序的、可以随机访问的，集合**：第一：相同数据类型，怎么看或者是如何定义数组存的是什么类型呢？在定义数组的时候就已经写得很清楚了：`int a[length];`，看到了吧，数组里存的是`int`类型；第二：有序，这里的有序其实指的是 **连续内存空间**，一个 `int` 型的变量可能计算机随便分配一块 *4字节* 内存给你，但如果你定义的是一个数组，例如长度为8，那计算机可能给你分配的就是一块 *32字节* 的连续内存，也就是这32字节，不是东一块西一块的，而是紧紧挨在一起、地址从小到大；第三：随机访问的集合，其实这个表述并不准确，因为在C++标准库里的集合是不支持 **随机访问** 的，而数组能随机访问的主要原因就是一个数组里面的每一个元素的地址是连续的，可以通过简单的地址加减就能访问到。（啊？你不知道什么叫做随机访问，不懂就问随机访问是用随机数访问吗？它指的是你可以任意查看或修改位于数组里面任意位置的元素，例如`a[9]`访问的是数组`a`的第`10`个元素。是的，后续我们会看到，有些 *数据结构* 不支持随机访问）。
  - 指针是 **变量**，对，不是妖魔鬼怪牛鬼蛇神魑魅魍魉界门纲目科属种的任何一类，它只是一个变量。这个变量的定义是在基本数据类型的保留字后面增加一个`*`符号，例如`int* p`定义的是指向`int`类型变量的指针。那这里就很迷：C++很聪明嘛，还知道 **指向**，如果你是这样认为的，那就是你不聪明了。所谓指针，确实是变量，因此 **它本身是有计算机分配的地址的**，也就是你可以输出 `&p` 来查看指针 `p` 的 **自己的** 地址；但变量总得存个值，那这个值是什么呢，在我们学习的时候我们会写这样的句子：`int a = 0; int *p = &a;` 或者 `int a = 0; int *p; p = &a;`，而运算符`&`可以理解为 **取地址**，也就是 **把`a`变量的地址返回出来**，因此指针变量`p`的 **值** 是地址，也就是你可以输出 `p` 来查看 `p` 的值，也就是 `a` 的地址。
  - 动态内存分配：主要使用 `new` `delete` 进行内存管理
  - 数组和指针的关系：一句话，数组名是指向数组起始地址的指针，也就是 `*array == &array[0]`

下面对每一章进行 **比较概括** 的总览。

## 程序、编译、内存、基本数据类型

### 程序

使用`windows`的同学可以尝试打开一个后缀名为`exe`的文件（怎么打开，强制打开，用记事本）（当然`linux`发行版、`macOS`可以查看一下权限中有`x`的文件），里面是一些人类无法理解（但是顶级人类可以理解）的符号。但是计算机是能看懂的，`exe`其实是“可执行文件”，你写的C++程序通过 **编译** 最后生成了它。你或许会说：啊？Visual Studio里面在哪找exe啊，我只知道打开sln然后点击运行就能运行我写的代码，这是程序吗？在此不做回答。于是这一门课为了让大家能理解甚至成为计算机，在学编程语言之前，总会让大家先学习二进制的基础知识。是的，所以复习的时候你应该去**熟悉**反码、补码、二进制的运算、进制换算（二进制换十进制，十进制换十六进制等等）。

### 编译

C++是一门 **编译型** 语言，所谓编译你可以理解为有一个叫做 **编译器（VS里面用的是MSVC）** 的东西，将程序员写的C++代码经过词法分析、语法分析、中间代码生成等步骤 **翻译** 成一个便于操作的中间代码，接着再将中间代码转成 **二进制** 代码，也就是计算机能看懂的代码。最后运行时，计算机操作系统经过一系列调度后，将这一段二进制代码加载到内存中运行，可能你的电脑在操作系统的调度下经过一系列的中断、信息传递、线程同步后终于把你的程序跑完了，而人看到的：我点击了运行，它输出了`1+1=2`。

### 内存

这里我们只需了解什么是内存，什么是地址就行了，至于堆区、栈区在后续学习中会逐渐熟悉。总所周知，是个东西，要存在于计算机中，就必须有“地方”让它存在。我们可以分为两个部分来看：假设你现在开着电脑，你的电脑里面有一个名为cpp的 **文件**，并且你现在正在打开浏览器，浏览这个网站。好，那么请你重启电脑。当你再次打开电脑时，你发现那个名为 cpp 的文件岿然不动地存在于电脑里面，而你刚刚用于冲浪的浏览器已经关闭了。这是因为你的文件存在 **硬盘** 里面，而你 **运行中的** 浏览器存在于 **内存** 中，它们都是 **存储空间**。不论哪一种存储方式，你都可以将其想象成一个 **坐标系**，并且是 **一维** 的。

那如何 **找到** 或者说 **唯一确定** 一组数据所在的位置呢？前面已经提示了，存储空间其实是可以看作多个一维坐标系的集合，**我们以内存空间为例**。空间对应着坐标，计算机内存的坐标就是所谓的 **地址**（当然，这里还会涉及到物理地址和逻辑地址以及它们的映射关系，但都是后话了，这里我们 **暂时** 把我们看到的地址就当作是数据的实际存放地址）。顺便假设我们的地址就是`0x0000`到`0xFFFF`，以十六进制表示（一个十六进制占4位，也就是半个字节，因为要表示16个不同的数，需要4位二进制；因此上面的地址一共是 $4\times 4=16$来位，也就是2个字节表示，能表示$2^{16}$不同的地址），例如一个`char`占1个字节，表示`0-255`范围大小的数。

那实际上计算机的地址是什么样的呢？

```cpp
int main() {
  int a = 10;
  int *p = &a;
  cout << p << endl;
  cout << &p << endl;
  cout << &a << endl;
  return 0;
}
```

输出是

```
0000005EBCBFFC90
0000005EBCBFFC88
0000005EBCBFFC90
```

可以看见

1. 地址的分配其实比较任意，如果你在报错时发现地址是类似`FFFFFFFF`大概率是访问了非法地址、空指针；如果你的报错也是一个随机的地址，可能是数组下标越界（因为访问的是数组规定范围后面的地址）
2. 一个程序的变量的分配比较连续（并不常常这样），`a`的地址是`0000005EBCBFFC90`，指针变量`p`的地址是`0000005EBCBFFC88`，相差的是十六进制的8位（...88~...90是8位），也就是32位二进制，4个字节，也就是一个`int`类型 **或者** 指针类型的大小，是不是十分合理
3. 指针本身有地址`0000005EBCBFFC88`，存的是变量的地址`0000005EBCBFFC88`

### 基本数据类型

[看这个](https://www.runoob.com/cplusplus/cpp-data-types.html)

> **变量初始化**：
> 很多人写代码都不初始化，还好一些比较善意的编译器在编译代码的时候会帮你初始化到一个合理的值。但是如果我们动态分配内存，并访问了其中的地址，其实大概率会访问到一些奇怪的值：`-8xxxxx`，`326xxxx`诸如此类。这是因为内存没有被初始化。
>
> - 基本数据类型变量初始化：直接用等号（赋值等于号）赋予初值即可
> - 数组初始化：在 **声明时** 可以用等号赋值的话使用初始化列表`{1, 2, 3}`之类；也可以后续用 **一重循环** 遍历下标，单独为每个元素赋值
> - 二重数组初始化：二重循环依次遍历

## 控制流语句

从这里往后，大家开始使用大括号了。什么？你说你的`if,while`都不用大括号？ **如果不用大括号，C++默认是紧接着`if,while`类似这句话的下一句是包括在语句内部的，其它的不算**。如果不喜欢大括号，这边建议[指路](https://www.python.org/)。

虽然在C++里面的某些代码格式（format），会要求大括号单独一行，也许你以为通过省略大括号能让你的代码看起来“简短”，让人感觉你用更少的代码写出了更好的程序；在编译器眼中：都一样。

### 条件语句

你需要熟练的地方：

- `if-else if-else`的关系中，`else`表示前面的条件不满足，才会判断`else if`的内容，不是每一个条件都会判断
- **逻辑短路** 的工作原理
- 两个变量相等是用`==`还是`=`
- `if`里到底要填啥（填布尔值），布尔条件到底是啥？为啥我随便填一个数好像也没错？没错，但最好你的表达式返回布尔类型的值。
- `switch-case`的语法以及在`case`块中加入`break`的作用，如果不加行不行（当然行啊），但为啥“一般”要加上
- `switch-case`中的`default`块在何时执行

### 循环语句

你需要熟练的地方：

- `for`语句的语法！！！在`for`里面有两个分号，其实是三句话，把这三句话对应到`while`里面分别位于循环的哪些部位，这三句话代表什么含义？能不能添油加醋（当然可以，但是我的评价就像我摘要写的那样）
- `while`语句的语法，`while()`的`()`里面到底填啥，填`1`和填`true`的区别是什么，作用是什么
- `do-while`语句的语法，这个循环最少执行多少次？并且是否一定会执行？
- `break, continue`的区别是什么？

### 变量的作用域

[参考](https://www.runoob.com/cplusplus/cpp-variable-scope.html)

一般而言，我们只能在 **函数内部，代码块（一对大括号内）内部，函数的形式参数列表，函数外部** 定义变量

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

**作用域**是程序的一个区域，变量的作用域可以分为以下几种：

- **块作用域：**在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **局部作用域：**在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域：**在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- 类作用域

作用域可以理解为你 **在哪可以看见这个变量，即可以访问、修改**。对于一个简单的例子：

```cpp
const int times = 10;

int main(){
  int a = 0;
  int i = 0;
  while (i < times) {
    i += 1;
    int a = 10;
  }
  cout << a << endl;
  return 0;
}
```

请问最后输出的 `a` 是多少。【0】，因为在`while`语句执行完后，内部的`a`由于是局部变量而被销毁（为什么是局部变量，难道不是在`main`函数定义的吗？【就近原则】）

## 函数

> **为什么会有函数？为什么叫做函数？如何使用函数？**
> 
> 其实在编码过程，我们经常发现某一段代码（假设有800行）经常会 **重复** 用到，因此需要到处复制粘贴。那我们能不能把这800行 ~~屎山~~ 代码给一个编号，于是叫做 xxx 代码块，也就是 **函数**。函数是代码中 **减少重复代码** 的典型例子之一。那为啥叫做函数呢？对于一段程序，事实上是对数据的一系列操作，最终 **呈现** 出某种效果（可能是算出来一个值，也可能是打印一句话） ，忽略中间部分（或者说把中间部分包裹起来），我只要提供这一段代码 **需要** 的值，并且运行完以后可以 **拿到** 我想要的值，就行了，也就是：`f: input -> output`，这不就映射嘛！那 **如何使用** 呢？`output = f(input)`，是不是就和数学上面的表示一模一样了。当然，在某些语言中也称函数为 *过程，方法*

函数分为 **声明** 、 **定义** 、 **调用**

- **函数声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。一般形式是 `return_type function_name( parameter list );`。在函数声明中，参数的名称并不重要，只有参数的类型是必需的。
- **函数定义**提供了函数的实际主体。
  - 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。
  - 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
  - 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
  - 函数主体：函数主体包含一组定义函数执行任务的语句。
- **调用函数**时，传递所需参数，如果函数返回一个值，则可以**存储**返回值。

### 道理我都懂，但函数到底是什么

上一节末尾，我们已经说到 **变量作用域**，其实函数是一个单独的作用域，除了输入输出和全局变量外，一般情况函数的所有部分和外界是分离开的。在使用函数时，一定要牢记 **名字只是符号**。

- 形式参数：就是一个形式，一个符号，可能是`void f(int a, int b);` 你可以这样**调用**`f(a1, b1)`，也可以这样调用`f(___, _111)`，总之不管怎样， **只要类型能对应**，不论参数是什么名字都无所谓
- 实际参数：指的是在 **调用** 时，传入函数的参数， **类型要和函数声明的参数类型一致**
- 返回值：有人说我在函数返回的是`int my_function(){return number;}`，也就是`number`这个变量啊，为什么我在调用的时候 **找不到number**？记住名字只是一个符号，你调用函数后拿到的是 **类型和值**，不是名字，**你需要用你自己定义的变量去接收这个类型和值**，例如`int my_number = my_function();`就可以通过`my_number`这个变量访问到函数的返回值；而函数内部的`number`变量已经随着函数调用的结束而析构。

### 奇怪的参数列表和返回值——引用

![函数调用传值方式](1704705699573.png)

你可以写一些简单的程序来测试

```cpp
void demo(int *_p) { *_p = 10; }

int main() {
  int a = 0;
  demo(&a);
  cout << a << endl;
  
  a = 0;
  int *p = &a;
  demo(p);
  cout << a << endl;
  return 0;
}
```

程序的输出是

```
10
10
```

### 递归

“自己调用自己”

理解递归的最好方式是 **画出函数调用图**。例如我们有这样的一个函数：

```cpp
int fib(int a) {
  if (a == 0 || a == 1) return 1;
  return fib(a - 1) + fib(a - 2);
}
```

如果我们传入参数10，则调用关系如下：

![递归](1704706343961.png)

在书写函数递归的时候要注意 **递归终点**。在递归结束前，最开始的函数是在等待下一层函数的返回值的，而下一层的函数又在等待下下一层的函数的返回值，一直持续到递归终点，可以返回（例如本例是当`a==0 || a==1`时是递归终点）

## 数组

数组很有意思，因为它让我们不用写`int a, b, c, d, e, ..., z, a1, b1, ...`这么多的数据来定义类型，只要`int a[个数]`就能定义指定个数的元素。想了一下感觉没啥例子，单独画个内存空间也觉得没意思，于是...

![一组物品](1704707101509.png)

在Minecraft里面，一般而言物品的最大堆叠上限（不加MOD）是64，那其实相当于一个数组，是同类型事物的聚集，有一定的大小。不过与数组不同的是，它每一个元素是 **完全一样的**，但C++里面的数组只要求 **类型一致**。

![存储形式](1704707535749.png)

不论如何，如果你只需要了解什么是数组，你只需要这么多就行了。但是，你还学习了指针。

但是我们先只讲一下静态数组。所谓静态，其实是指数组的大小在 **编译** 时是确定的（啊？我怎么知道编译时什么是常量），你可以简单理解为 **常量**，例如宏定义的量（`#define len 10`）、`const`修饰的 **整型** 变量（`const int,const  short, const long, const unsigned, const char, const size_t, const uint...`）、字面整型值（`1,10,100...`），**一旦定义的时候指定数组大小，后续使用都不得更改**。静态数组的定义和初始化：`int a[10] = { 0 };`。数组的使用：`a[idx]`，其中`idx`是下标值，范围是`0 ~ (length - 1)`。

讲这些其实没有意思，但不妨来讨论 **二维数组**、**字符数组**

- **二维数组**：本质是指针的数组，定义的时候 **最好** 把两个维度大小都指定好，并且初始化时可以使用 **二重循环** 进行初始化
- **字符数组**：可以使用头文件 `string` 中的内置函数进行操作，它的初始化可以直接用字符串进行初始化，！！注意！！我们暂时**不允许使用** `string` 类型

**关于缺省定义**（灰色中括号内部为代码提示，可以忽略）

![缺省定义](1704715511118.png)

**关于字符数组初始化**

![字符数组初始胡](1704715774813.png)

你需要掌握：

- 数组如何定义，数组如何传给函数，函数如何返回数组
- 在函数内修改数组元素的值，函数返回后会不会改变该数组
- 编程时要注意检查数组下标是否溢出
- 数组初始化
- 字符数组初始化记得给`'\0'`留空间

## 指针

始终记住，指针是一个变量，自己在内存中有一块地址用于存储某些值，而指针能存的值 **只能是** 地址。那有人就问了，**指针能存自己的地址吗**？[这个无聊且有趣的问题甚至真有探讨过](https://zhuanlan.zhihu.com/p/593510473)

在声明指针时，我们常常同时去定义这个指针：

```cpp
int val = 10;
int * p_val = &val;
```

在上述代码中，我们定义了一个 **指向`int`类型的指针变量`p_val`**，它的 **值** 是 `val` 的地址。如果看不懂我在说什么，那...一图胜千言吧

![指针](1704714262435.png)

> - 对于指针定义，我们可以这样看：把`int*`看作一个整体，表示我马上要定义一个`int`型指针，而`p_val`就是这个指针的名字，又从指针内存的值的类型而言，应该赋值为一个地址`&val`，其中`&`用于 **取地址**
> - 对于**指针指向的值**的使用，我们经常会这样用：`*p_val = something`。于是我们对 **定义** 可以解读为 `int` 型变量 `*p_val`，而 **在使用中**，`*p_val`确实是`int`型的，其中`*`用于 **解引用**

你需要掌握：

- 指针如何初始化，比如`NULL`或者`nullptr`，避免指针成为野指针
- 指针如何传递给函数，函数如何返回指针
- 指针和引用的区别是什么
- 引用如何传递给函数，函数如何返回引用
- 引用有哪些作用
- 指针如何动态分配内存，又如何销毁内存

### 动态内存分配

在C++中，我们使用`new`保留字来 **分配内存**，一般这样使用：

```cpp
int *p1 = new int;
int *p2 = new int[10];
```

也就是其返回的是 **指向被分配的内存的地址**，因此要用指针变量来接收这个表达式的返回值。除此之外，内存大小其实由 **数据类型** 和 **数据的个数** 决定，因此在 `new` 的后面需要告诉你的程序要分配多大的内存。
值得注意的是，这个分配过程是 **动态** 的，也就是说在程序运行时，无需保证分配的内存大小是编译时常量，可以 **动态** 指定。

当然，在这块内存没有利用价值的时候，可以进行 `delete` 来标记这块内存再也不用了。语法是

```cpp
delete p1;
delete[] p2;
```

> **注意**：很多同学会用这种方式拿到的指针作为数组使用，务必要进行 **初始化**。刚开辟出来的内存毕竟是一块蛮荒之地，需要你带过去文明的火种。

## 其它

在这里推荐一个比较适合复习的网站：[C++教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)，里面有很多例子。

### 结构体 struct

类型的集合，自己本身也是类型。

> **注意**：C++不能直接输出结构体，C++如果要输出结构体必须 **重载** 流运算符（啊？）当然我并没有阻止大家定义一个专门用于结构体输出的函数
>
> ```cpp
> struct MyStruct{
>   int data1;
>   char data2[10];
> 
>   // 用于输出结构体的函数
>   void print_struct() {
>     cout << data1 << endl;
>     for (int i = 0; i < 10; i += 1) {
>       cout << data2[i] << " ";
>     }
>     cout << endl;
>   }
> };
> ```
>
> 调用的时候：`MyStruct ms; ms.print_struct();`即可。其中运算符`.`表示的 **访问成员函数**，如果后面跟的是`struct`内的变量，也表示 **访问成员变量**

### 赋值

- 如果数组在定义时没有一次性赋值，那么后续想要 **对整个数组** 赋值，需要使用循环，**包括字符数组**
- 结构体`struct`类型......最好单个属性赋值（等了解多了以后再进行一次性赋值）

### IO操作

不会有人还不会输入输出吧...

### 随机初始化

如何使用C++进行随机初始化
